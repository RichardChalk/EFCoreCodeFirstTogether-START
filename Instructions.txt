A. Öppna START koden 
https://github.com/RichardChalk/EFCoreCodeFirstTogether-START

B. …Skapa en ny Console app och kopiera koden från START projektet ovan ett steg i taget 
enligt instruktions i denna fil…


** **************************************************************************************
Standard inställningar
** **************************************************************************************
1: Skapa en console app
2: Lägg till appsettings.json. Uppdatera databas namnet (valfritt). Kom ihåg property "Copy if newer"

	{
	  "ConnectionStrings": {
	    "DefaultConnection": "Server=localhost;Database=Invoice12345;Trusted_Connection=True;TrustServerCertificate=true;MultipleActiveResultSets=true"
	  },
	  "Logging": {
	    "LogLevel": {
	      "Default": "Information",
	      "Microsoft": "Warning",
	      "Microsoft.Hosting.Lifetime": "Information"
	    }
	  },
	  "AllowedHosts": "*"
	}

I en konsolapp måste du ofta ändra egenskapen till "Copy if newer" för filer som 
.json-konfigurationsfiler för att säkerställa att de kopieras till bin-mappen när du bygger 
eller kör applikationen. 
Detta är viktigt för att applikationen ska hitta rätt version av filen vid körning.

Här är varför "Copy if newer" är användbart:
Undviker onödiga kopieringar: 
	Filen kopieras endast om den har ändrats, vilket kan minska byggtiden.
Garanterar att senaste versionen används: 
	Om du ändrar konfigurationsfilen eller någon annan resurs kopieras den automatiskt 
	till output-mappen, så du alltid får uppdaterade inställningar.

3: Installera alla nuget paket (matchar version)
	Microsoft.EntityFrameworkCore.SqlServer
	Microsoft.EntityFrameworkCore.Tools
	Microsoft.Extensions.Configuration.json
4: Create json builder (boiler plate code) i Main()
        var builder = new ConfigurationBuilder().AddJsonFile($"appsettings.json", true, true);
        var config = builder.Build();
5: Create 'Data' folder. Create classes.
	1. Person (obs:Exkl. Annotations & 'ShoeSize' & 'County')
	2. Invoice
6: i 'Data' folder create en ny ApplicationDbContext class (boiler plate code). (exkl. DbSet<County>) 
   I Main() create options & connectionstring variables (boiler plate code).
	var options = new DbContextOptionsBuilder<ApplicationDbContext>();
	var connectionString = config.GetConnectionString("DefaultConnection");
	options.UseSqlServer(connectionString);
7a: Kör i console 
	add-migration "Initial migration"
7b: I Main migrate DbSets to SQL tabeller!
    Detta kommer att skapa din databas på din lokala DBServer!!! Ta en titt!
    OBS: .Migrate() motsvarar update-database i konsolen!
	using (var dbContext = new ApplicationDbContext(options.Options))
	{
	    dbContext.Database.Migrate();
	}
   
7c: F5! 
    OBS: Ingenting händer i konsolen!!! Men kika på din SQL Server!
         Nu finns det en ny databas där! Coooolt!

** **************************************************************************************
Best practise
** **************************************************************************************
8: Vi vill lämna 'Main' static class och jobbar i vår egen class som heter 'Application'
	Skapa en ny class i som heter "Application.cs" (på root nivå - samma som Program.cs)
	Lägg till all denna kod

        public void Run()
        {
            // 4: Create json builder (boiler plate code)
            // Makes it possible to connect to appsettings.json
            var builder = new ConfigurationBuilder()
                .AddJsonFile($"appsettings.json", true, true);
            var config = builder.Build();

            // 6: Create DBContext(boiler plate code).
            // Create options & connectionstring variables(boiler plate code).
            var options = new DbContextOptionsBuilder<ApplicationDbContext>();
            var connectionString = config.GetConnectionString("DefaultConnection");
            options.UseSqlServer(connectionString);

            // 7a: Kör i console add-migration "Initial migration"
            // 7b: Migrate DbSets to SQL tabeller
            // Om inte databasen redan finns... så skapas den nu.
            using (var dbContext = new ApplicationDbContext(options.Options))
            {
                dbContext.Database.Migrate();
            }
        }

	I Main lägg till denna kod (och raderar all kod som finns där nu!)
	
	using DeleteMe;

	// 8: Vill vill lämna 'Main' static class och jobbar i vår egen class som heter 'Application'
	var app = new Application();
	app.Run();

8b: Radera din databas på din SQL Server.
8c: Kör programmet igen för att kontrollerar att allting fungerar 
    som det ska och att din databas skapas på nytt!


** **************************************************************************************
Template
** **************************************************************************************
INFO: Nu är din databas skapad och du har tillgång till datat via din DbContext 
Här skulle du kunna skapa en kopia av projektet och använder den som en template
De saker som man behöver ändra på om man ska använda denna template till ett nytt projekt är:
	a: Ändra namnet på databasen i din appsettings.json
	b: Ändra namnet på databasen i din dbContext (OnConfiguring metod)
	c: Ändra klasserna så att de matchar den nya databas du vill skapa
	d: Radera mappen som heter "Migrations"
	e: Kör add-migration "Initial migration" igen
That's it!!!

** **************************************************************************************
add-migration
** **************************************************************************************
INFO: Varje gång vi vill ändra i vår databas schema (add kolumn eller tabell) måste vi köra tex:
	add-migration "Column added"
EF Core är så kraftfull att den skapar en ny migration och lägga till det som är tillagd
i vår databas. Den är så smart att den kör ENDAST de saker som är nya....


** **************************************************************************************
Attributes
** **************************************************************************************
https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwithout-nrt
INFO: Attributes hjälper oss att bestämma hur våra kolumner ska se ut (vilka properties de har)

9: Create some attributes for our Person table columns tex.

OBS: Använd [Required] om du vill garantera att databaskolumnen blir NOT NULL och samtidigt 
     möjliggöra validering i kod.
Name	[Required] [MaxLength(100)]
Age	[Range(15,100)]
Id	[Key]

OBS: [Key]
Denna annotation behövs om min Primary Key döps till något annat än just "Id"

OBS: Om man kör F5 nu blir det ERROR! Eftersom vi har ändringar i vår C# App 
     som INTE matchar SQL databasen! Se error nedan...
     "The model for context 'ApplicationDbContext' has pending changes. 
      Add a new migration before updating the database." 

BEFORE - Titta på Person tabellen i SQL Server - Gå till Design läge

Kom ihåg! Nu har vi ändrat på vår databas!
Då måste vi köra en ny add-migration.. .tex:
add-migration "Added attributes to Name & Age"

När vi kör vår app med F5 så kommer databasen att uppdateras. Tack vare 
	dbContext.Database.Migrate();

AFTER - Titta på Person tabellen i SQL Server - Gå till Design läge
        Vi ser att NAme length är numera nmax 100!
	Age ser likadant ut... Range gäller endast validering och ändra inte schemat!

** **************************************************************************************
Lägg till en kolumn i en befintlig tabell
** **************************************************************************************
10: Vi lägger till en kolumn i 'Person' classen. tex:
ShoeSize	[Range(1,60)]

Kom ihåg! Nu har vi ändrat på vår databas!
Då måste vi köra en ny add-migration.. .tex:
add-migration "Added ShoeSize to person"

När vi kör vår app med F5 så kommer databasen att uppdateras. Tack vare 
	dbContext.Database.Migrate();
Titta på Person tabellen i SQL Server - Nu finns ShoeSize!


** **************************************************************************************
Lägg till en ny tabell
** **************************************************************************************
11: Vi lägger till en helt ny tabell (C# class) som heter 'County' (i 'Data' mappen).

Lägg till 'County' som en DbSet<> i din dbcontext
	public DbSet<County> County { get; set; }

Kom ihåg! Nu har vi ändrat på vår databas!
Då måste vi köra en ny add-migration.. .tex:
add-migration "Added County table"

När vi kör vår app med F5 så kommer databasen att uppdateras. Tack vare 
	dbContext.Database.Migrate();

INFO: Vi skulle kunna tom. ändra namnet på databasen (tex. 'InvoiceVersion2') i appsettings.json och spara 
allt till en ny databas. Inclusive alla vår migrations!

Titta på County tabellen i SQL Server - Woohoo!!


** **************************************************************************************
OH NO!!! Vi glömde koppla 'County' till vår 'Person'
** **************************************************************************************
12: Vi vill koppla varje 'Person' till en 'County'. tex:

INFO: Rita ut en databas diagram från SSMS
      Vi ser att Person har ingen relation med County!

Lägg till denna kod i Person (Cardinality - One to One)
	public County County { get; set; }

Kom ihåg! Nu har vi ändrat på vår databas!
Då måste vi köra en ny add-migration.. .tex:
add-migration "Connected Person to County"

När vi kör vår app med F5 så kommer databasen att uppdateras. Tack vare 
	dbContext.Database.Migrate();

INFO: Rita ut en ny databas diagram från SMMS
      Nu är Person kopplad till County!

** **************************************************************************************
Best practise
** **************************************************************************************
13: Create a new class 'DataInitializer' (i 'Data' mappen) med en Metod som heter 'MigrateAnDSeed(dbContext)'

(BEST PRACTISE)
Nu kan vi flytta raden i vår Application class 
	dbContext.Database.Migrate();
Till vår nya metod I DataInitializer klassen
OBS: Detta skapar jordgubbsland eftersom vi har inte skapat metoden SeedCountys än... det kommer :)
	public void MigrateAndSeed(ApplicationDbContext dbContext)
        {
            dbContext.Database.Migrate();
            SeedCountys(dbContext);
            dbContext.SaveChanges();
        }

Ändra using till denna kod i Application.cs metod Run()
	using (var dbContext = new ApplicationDbContext(options.Options))
	{
		var dataInitiaizer = new DataInitializer();
		dataInitiaizer.MigrateAndSeed(dbContext);

		// Migrate har flyttats till dataInitializer class (BEST PRACTISE)
		// dbContext.Database.Migrate();
	}


** **************************************************************************************
SEED Data (Stödtabell - County)
** **************************************************************************************
14: Fyll på stödtabellen 'County'.
Skapa en metod i DataInitializer klassen som heter 
	SeedCountys(ApplicationsDbContext dbContext)

INFO: Kör din app med F5. Kolla nu på din databas... 
Ser du att det finns data i County tabellen numera? Seeding baby! Coooolt!

Varje gång din app körs så kommer detta data att skapas (om det inte finns redan!)
OBS: Även om du skulle av misstag ta bort data i County

OBS2: Jag behöver inte köra 'add-migration' eftersom jag ändrar INTE på database schemat!
      Det enda jag gör är lägga till data... :)

** **************************************************************************************
(C)REATE
** **************************************************************************************
15: I Application.cs 
Vi ger användaren möjlighet att skapa nya personer och lägger till de i databasen
(kopiera koden från START appen)

F5 - Testa att lägga in en person
     Titta i SSMS på den nya personen! Woohoo!

** **************************************************************************************
(R)EAD
** **************************************************************************************
16:  I Application.cs 
Vi ger användaren möjlighet att se alla personer som finns i vår databas
(kopiera koden från START appen)

17a: Sätt en breakpoint på Read koden... varför är 'County' null i min 'person' (i foreach loopen)

Hmmm varför ser inte jag någon information i 'County'?
17b: Jag måste nog köra INCLUDE för att få se datat....


** **************************************************************************************
(U)PDATE
** **************************************************************************************
18:  I Application.cs 
Vi ger användaren möjlighet att uppdatera befintliga personer som finns i vår databas
(kopiera koden från START appen)


** **************************************************************************************
(D)ELETE
** **************************************************************************************
19:  I Application.cs 
Vi ger användaren möjlighet att radera befintliga personer som finns i vår databas
(kopiera koden från START appen)

En fråga... Är det bra att vi använder .Remove() metoden?
